### 07:08 - Create Team data model with fixed lane/slot shape [gpt-5-codex]

**User Prompt:**
create the data model for a team. A team has an array of 3 lanes, each lane has an array of two card slots.

**Issues Encountered:**
- No blocker encountered

**Decisions Made:**
- Added a dedicated `Team` model with tuple-based types to enforce exactly 3 lanes and 2 slots per lane at compile time
- Added Zod schemas for runtime validation to enforce the same constraints from external data
- Represented each slot as `{ cardId: string | null }` to support both occupied and empty slots

**Technical Info Consulted:**
- `AGENTS.md` for project conventions and journal format requirements
- `ui/src/shared/models/card.ts`
- `ui/src/shared/models/card.schema.ts`
- `ui/src/shared/models/models.test.ts`
- `docs/design/datamodel.md`

**Assumptions Made:**
- A "card slot" should explicitly exist even when empty, represented by `cardId: null`
- Team model should be exported through `ui/src/shared/models/index.ts` like other models

**Other Notes:**
- Added tests for valid team shape, invalid lane count, invalid slot count, and slot `cardId` validation

### 07:09 - Switch Team model from tuples to arrays for dynamic geometry [gpt-5-codex]

**User Prompt:**
use array instead of tuples, since mods or effects may change this later

**Issues Encountered:**
- No blocker encountered

**Decisions Made:**
- Replaced tuple-based `Lane` and `TeamLanes` with array-based types
- Replaced tuple-based Zod schemas with array schemas to allow variable lane/slot counts
- Updated tests to assert that dynamic lane and slot counts are accepted
- Updated design documentation to describe dynamic team geometry

**Technical Info Consulted:**
- `ui/src/shared/models/team.ts`
- `ui/src/shared/models/team.schema.ts`
- `ui/src/shared/models/models.test.ts`
- `docs/design/datamodel.md`

**Assumptions Made:**
- Dynamic board shape should be supported by the core data model and validation layer

**Other Notes:**
- `cardId` validation remains unchanged (`null` or non-empty string)

### 07:13 - Store full Card objects in Team slots [gpt-5-codex]

**User Prompt:**
The CardSlot should reference an actual card, since its values may change at gametime

**Issues Encountered:**
- No blocker encountered

**Decisions Made:**
- Changed `CardSlot` from `{ cardId: string | null }` to `{ card: Card | null }`
- Switched runtime slot validation to use `CardSchema` so embedded cards are fully validated
- Updated team tests to pass real card objects and reject invalid embedded card shapes
- Updated design documentation to reflect live card references in slots

**Technical Info Consulted:**
- `ui/src/shared/models/team.ts`
- `ui/src/shared/models/team.schema.ts`
- `ui/src/shared/models/card.ts`
- `ui/src/shared/models/card.schema.ts`
- `ui/src/shared/models/models.test.ts`
- `docs/design/datamodel.md`

**Assumptions Made:**
- Team slots should carry current in-battle card state directly, not only static catalog identifiers

**Other Notes:**
- Existing dynamic lane/slot array behavior remains unchanged

### 07:25 - Add deterministic battle computer with combat events [gpt-5-codex]

**User Prompt:**
Create the battle computer that computes battle outcomes. Battles MUST be fully deterministic. Enforce this with a RNG interface, and using a deterministic PRNG.

Inputs are two teams, the output is a CombatResult, which has a winner, as well as an array of CombatEvents.
CombatEvents are a chronological series of events that happened in combat. Currently only model "attack" and "faint" events.

**Issues Encountered:**
- No blocker encountered

**Decisions Made:**
- Added a dedicated battle computer module with explicit `Rng` interface
- Implemented deterministic PRNG (`xorshift32`) and routed all random choices through the RNG
- Created `CombatResult` and typed `CombatEvent` union with `attack` and `faint` variants
- Implemented battle simulation using mutable runtime unit state derived from team slot cards
- Added deterministic and chronology-focused tests for battle outcomes

**Technical Info Consulted:**
- `ui/src/shared/models/team.ts`
- `ui/src/shared/models/card.ts`
- `ui/src/shared/models/cards.ts`
- `docs/design/datamodel.md`

**Assumptions Made:**
- Target/attacker selection among alive units should be RNG-driven, but deterministic through seeded PRNG
- Battles with no living units on both sides should resolve as `draw`

**Other Notes:**
- The simulation does not mutate input team/card objects

### 07:31 - Apply simultaneous attacker/defender damage in battle [gpt-5-codex]

**User Prompt:**
when attacking, the defender deals its attack to the attacker as well

**Issues Encountered:**
- No blocker encountered

**Decisions Made:**
- Updated attack resolution so both attacker and defender deal damage in the same combat step
- Extended `attack` event payload to include both damage directions and both defense before/after values
- Preserved chronological event stream by emitting `attack` first, then one or two `faint` events
- Added tests for reciprocal damage and mutual faint outcomes

**Technical Info Consulted:**
- `ui/src/shared/combat/battle-computer.ts`
- `ui/src/shared/combat/battle-computer.test.ts`
- `docs/design/datamodel.md`

**Assumptions Made:**
- Defender retaliation should occur even if the defender reaches 0 defense from that same attack

**Other Notes:**
- Input team/card objects remain unchanged after simulation

### 07:37 - Add battle snapshot test for deterministic combat result [gpt-5-codex]

**User Prompt:**
In the test file, run a complete battle and do a snapshot test for the combat result.

**Issues Encountered:**
- No blocker encountered

**Decisions Made:**
- Added a full battle test scenario with multiple cards per team
- Used `computeCombatResult` to validate complete deterministic output
- Added `toMatchSnapshot()` assertion and generated an inline snapshot file via Vitest update mode

**Technical Info Consulted:**
- `ui/src/shared/combat/battle-computer.test.ts`
- `ui/src/shared/combat/battle-computer.ts`

**Assumptions Made:**
- Snapshot stability is guaranteed because battle simulation uses deterministic RNG

**Other Notes:**
- Snapshot was generated by running `vitest` with `--update`
